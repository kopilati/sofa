version: '3'

vars:
  CLUSTER_NAME: sofa-test
  IMAGE_NAME: sofa:latest
  AUDIT_IMAGE_NAME: audit-service:latest
  NAMESPACE: default
  SOFA_PORT: 30081
  KEYCLOAK_PORT: 30082
  AUDIT_PORT: 30083
  ENVIRONMENT: dev # default environment
  SOFA_URL: http://localhost:{{.SOFA_PORT}}

tasks:
  build:
    desc: Build the Sofa Docker image
    cmds:
    - echo "Building Sofa Docker image..."
    - docker build -t {{.IMAGE_NAME}} ./sofa

  build-audit:
    desc: Build the Audit Service Docker image
    cmds:
    - echo "Building Audit Service Docker image..."
    - docker build -t {{.AUDIT_IMAGE_NAME}} ./audit-service

  rollout:
    desc: Build Sofa, load the image into Kind, and rollout the deployment
    cmds:
    - echo "Building and rolling out Sofa..."
    - task: build
    - kind load docker-image {{.IMAGE_NAME}} --name {{.CLUSTER_NAME}}
    - kubectl rollout restart deployment/{{.ENVIRONMENT}}-sofa
    - kubectl wait --for=condition=available deployment/{{.ENVIRONMENT}}-sofa --timeout=60s
    - echo "Sofa has been rebuilt and deployed"

  rollout-audit:
    desc: Build Audit Service, load the image into Kind, and rollout the deployment
    cmds:
    - echo "Building and rolling out Audit Service..."
    - task: build-audit
    - kind load docker-image {{.AUDIT_IMAGE_NAME}} --name {{.CLUSTER_NAME}}
    - kubectl apply -f ./audit-service/k8s/audit-service.yaml
    - kubectl wait --for=condition=available deployment/{{.ENVIRONMENT}}-audit-service --timeout=60s
    - echo "Audit Service has been rebuilt and deployed"

  port-forward-audit:
    desc: Set up port forwarding for Audit Service only
    cmds:
    - |
      echo "Setting up port forwarding for Audit Service..."
      echo "Audit Service will be available at: http://localhost:{{.AUDIT_PORT}}"
      echo ""
      echo "Press Ctrl+C to stop port forwarding"
      kubectl port-forward svc/{{.ENVIRONMENT}}-audit-service {{.AUDIT_PORT}}:80

  create-cluster:
    desc: Create a Kind cluster if it doesn't exist
    cmds:
    - |
      if ! kind get clusters | grep -q {{.CLUSTER_NAME}}; then
        echo "Creating Kind cluster..."
        kind create cluster --name {{.CLUSTER_NAME}} --config kind-config.yaml
      else
        echo "Kind cluster already exists, skipping creation."
      fi

  load-image:
    desc: Load the Sofa image into the Kind cluster
    deps: [ build, create-cluster ]
    cmds:
    - echo "Loading Sofa image into Kind cluster..."
    - kind load docker-image {{.IMAGE_NAME}} --name {{.CLUSTER_NAME}}

  load-audit-image:
    desc: Load the Audit Service image into the Kind cluster
    deps: [ build-audit, create-cluster ]
    cmds:
    - echo "Loading Audit Service image into Kind cluster..."
    - kind load docker-image {{.AUDIT_IMAGE_NAME}} --name {{.CLUSTER_NAME}}

  apply-manifests:
    desc: Apply all Kubernetes manifests using Kustomize
    deps: [ load-image ]
    cmds:
    - echo "Applying Kubernetes resources using Kustomize for {{.ENVIRONMENT}} environment..."
    - kubectl apply -k k8s/overlays/{{.ENVIRONMENT}}
    - |
      echo "Waiting for services to be ready..."
      kubectl wait --for=condition=available deployment/{{.ENVIRONMENT}}-couchdb --timeout=90s || true
      kubectl wait --for=condition=available deployment/{{.ENVIRONMENT}}-sofa --timeout=90s || true
      kubectl wait --for=condition=available deployment/{{.ENVIRONMENT}}-keycloak --timeout=120s || true

      echo "Services are available in the cluster. Use port-forwarding to access them."
      echo "Run 'task port-forward' to access the services."

  enable-audit:
    desc: Enable audit logging in SOFA by configuring it to use the audit service
    cmds:
    - |
      echo "Patching SOFA configuration to enable audit logging..."
      kubectl patch configmap {{.ENVIRONMENT}}-sofa-config -p '{"data":{"audit_enabled":"true","audit_log_service_url":"http://{{.ENVIRONMENT}}-audit-service/audit"}}'
      echo "Restarting SOFA to apply changes..."
      kubectl rollout restart deployment/{{.ENVIRONMENT}}-sofa
      kubectl wait --for=condition=available deployment/{{.ENVIRONMENT}}-sofa --timeout=60s
      echo "Audit logging has been enabled in SOFA"

  port-forward:
    desc: Set up port forwarding for both Sofa and Keycloak
    cmds:
    - |
      echo "Setting up port forwarding for Sofa and Keycloak..."
      echo "Sofa will be available at: http://localhost:{{.SOFA_PORT}}"
      echo "Keycloak will be available at: http://localhost:{{.KEYCLOAK_PORT}}"
      echo "Keycloak admin console: http://localhost:{{.KEYCLOAK_PORT}}/admin (admin/admin)"
      echo ""
      echo "Press Ctrl+C to stop port forwarding"
      echo ""

      # Start port forwards in background
      kubectl port-forward svc/{{.ENVIRONMENT}}-sofa-service {{.SOFA_PORT}}:80 & 
      SOFA_PF_PID=$!

      kubectl port-forward svc/{{.ENVIRONMENT}}-keycloak-service {{.KEYCLOAK_PORT}}:8080 &
      KC_PF_PID=$!

      # Set up trap to kill background processes on exit
      trap "kill $SOFA_PF_PID $KC_PF_PID" EXIT INT TERM

      # Keep script running
      echo "Port forwarding active. Press Ctrl+C to exit."
      tail -f /dev/null

  port-forward-all:
    desc: Set up port forwarding for Sofa, Keycloak, and Audit Service
    cmds:
    - |
      echo "Setting up port forwarding for Sofa, Keycloak, and Audit Service..."
      echo "Sofa will be available at: http://localhost:{{.SOFA_PORT}}"
      echo "Keycloak will be available at: http://localhost:{{.KEYCLOAK_PORT}}"
      echo "Audit Service will be available at: http://localhost:{{.AUDIT_PORT}}"
      echo "Keycloak admin console: http://localhost:{{.KEYCLOAK_PORT}}/admin (admin/admin)"
      echo ""
      echo "Press Ctrl+C to stop port forwarding"
      echo ""

      # Start port forwards in background
      kubectl port-forward svc/{{.ENVIRONMENT}}-sofa-service {{.SOFA_PORT}}:80 & 
      SOFA_PF_PID=$!

      kubectl port-forward svc/{{.ENVIRONMENT}}-keycloak-service {{.KEYCLOAK_PORT}}:8080 &
      KC_PF_PID=$!

      kubectl port-forward svc/{{.ENVIRONMENT}}-audit-service {{.AUDIT_PORT}}:80 &
      AUDIT_PF_PID=$!

      # Set up trap to kill background processes on exit
      trap "kill $SOFA_PF_PID $KC_PF_PID $AUDIT_PF_PID" EXIT INT TERM

      # Keep script running
      echo "Port forwarding active. Press Ctrl+C to exit."
      tail -f /dev/null

  port-forward-sofa:
    desc: Set up port forwarding for Sofa only
    cmds:
    - |
      echo "Setting up port forwarding for Sofa..."
      echo "Sofa will be available at: http://localhost:{{.SOFA_PORT}}"
      echo ""
      echo "Press Ctrl+C to stop port forwarding"
      kubectl port-forward svc/{{.ENVIRONMENT}}-sofa-service {{.SOFA_PORT}}:80

  port-forward-keycloak:
    desc: Set up port forwarding for Keycloak only
    cmds:
    - |
      echo "Setting up port forwarding for Keycloak..."
      echo "Keycloak will be available at: http://localhost:{{.KEYCLOAK_PORT}}"
      echo "Keycloak admin console: http://localhost:{{.KEYCLOAK_PORT}}/admin (admin/admin)"
      echo ""
      echo "Press Ctrl+C to stop port forwarding"
      kubectl port-forward svc/{{.ENVIRONMENT}}-keycloak-service {{.KEYCLOAK_PORT}}:8080

  setup:
    desc: Complete setup - build, create cluster, load image, and apply manifests
    deps: [ load-image, apply-manifests ]
    cmds:
    - |
      # Skip Keycloak connectivity checks during setup for now
      echo "Setup complete!"
      echo "To access the services, run: task port-forward"
      echo ""
      echo "Services will be available at:"
      echo "  - Sofa: http://localhost:{{.SOFA_PORT}}"
      echo "  - Keycloak: http://localhost:{{.KEYCLOAK_PORT}}"
      echo ""
      echo "Keycloak admin console will be available at:"
      echo "  http://localhost:{{.KEYCLOAK_PORT}}/admin"
      echo "  Username: admin"
      echo "  Password: admin"

  setup-audit:
    desc: Setup and deploy the audit service
    deps: [ load-audit-image ]
    cmds:
    - |
      echo "Applying Audit Service manifests..."
      kubectl apply -f ./audit-service/k8s/audit-service.yaml
      kubectl wait --for=condition=available deployment/{{.ENVIRONMENT}}-audit-service --timeout=60s
      echo "Audit Service setup complete! Run 'task enable-audit' to configure SOFA to use it."
      echo "You can access the Audit Service at: http://localhost:{{.AUDIT_PORT}} (after running port-forward-audit)"

  keycloak-ready:
    desc: Check if Keycloak is ready and properly configured
    deps: [ apply-manifests ]
    cmds:
    - |
      echo "Checking if Keycloak is ready..."
      # Wait for keycloak to be available
      kubectl wait --for=condition=available deployment/{{.ENVIRONMENT}}-keycloak --timeout=120s || true
      echo "To access Keycloak admin console, run: task port-forward-keycloak"
      echo "Then access: http://localhost:{{.KEYCLOAK_PORT}}/admin"
      echo "Username: admin"
      echo "Password: admin"

  switch-env:
    desc: Switch the active environment (dev, test, prod)
    interactive: true
    cmds:
    - |
      if [ -z "{{.CLI_ARGS}}" ]; then
        echo "Usage: task switch-env -- [dev|test|prod]"
        exit 1
      fi

      if [ "{{.CLI_ARGS}}" != "dev" ] && [ "{{.CLI_ARGS}}" != "test" ] && [ "{{.CLI_ARGS}}" != "prod" ]; then
        echo "Invalid environment. Please specify one of: dev, test, prod"
        exit 1
      fi

      # Create a temporary file with updated vars
      cat > .env.temp << EOF
      ENVIRONMENT={{.CLI_ARGS}}
      EOF

      echo "Environment switched to {{.CLI_ARGS}}"

      # Prompt to apply changes immediately
      read -p "Do you want to apply changes immediately? (y/n) " apply
      if [ "$apply" = "y" ] || [ "$apply" = "Y" ]; then
        task apply-manifests ENVIRONMENT={{.CLI_ARGS}}
      fi

  show-env:
    desc: Show the current environment
    cmds:
    - |
      echo "Current environment: {{.ENVIRONMENT}}"

  # CouchDB Operations Tasks
  create-database:
    silent: true
    desc: Create a database in CouchDB with authentication (requires port-forwarding)
    cmds:
    - |
      # Parse arguments
      SKIP_CHECKS=false
      ARGS=()
      for arg in {{.CLI_ARGS}}; do
        if [ "$arg" = "--skip-checks" ]; then
          SKIP_CHECKS=true
        else
          ARGS+=("$arg")
        fi
      done

      if [ ${#ARGS[@]} -lt 1 ]; then
        echo "Usage: task create-database -- <database_name> [--skip-checks]"
        echo "Example: task create-database -- my_database"
        exit 1
      fi

      DB_NAME=${ARGS[0]}
      echo "Creating database '$DB_NAME'..."

      # Check if Sofa port-forwarding is active using ps
      if [ "$SKIP_CHECKS" = "false" ]; then
        echo "Checking if Sofa port-forwarding is active..."
        if ps aux | grep -v grep | grep "kubectl port-forward.*{{.ENVIRONMENT}}-sofa-service.*{{.SOFA_PORT}}:80" > /dev/null; then
          echo "‚úÖ Sofa port-forwarding is already active"
        else
          echo "‚ùå Sofa port-forwarding is not active. Will attempt to start port-forwarding..."
          
          # Check if the service exists before attempting port-forwarding
          echo "Checking if {{.ENVIRONMENT}}-sofa-service exists..."
          if ! kubectl get svc {{.ENVIRONMENT}}-sofa-service &>/dev/null; then
            echo "‚ùå Service {{.ENVIRONMENT}}-sofa-service does not exist!"
            echo "Current environment: {{.ENVIRONMENT}}"
            exit 1
          fi
          
          echo "Starting Sofa port-forwarding..."
          kubectl port-forward svc/{{.ENVIRONMENT}}-sofa-service {{.SOFA_PORT}}:80 > /dev/null 2>&1 &
          echo "‚úÖ Started Sofa port-forwarding"
          
          # Give it a moment to establish
          sleep 2
          
          # Verify port-forwarding is running
          if ! ps aux | grep -v grep | grep "kubectl port-forward.*{{.ENVIRONMENT}}-sofa-service.*{{.SOFA_PORT}}:80" > /dev/null; then
            echo "‚ùå Port-forwarding process not found after starting. Something went wrong."
            exit 1
          fi
        fi
        
        # Quick connectivity check before proceeding
        echo "Checking connectivity to Sofa..."
        curl -s --connect-timeout 3 -o /dev/null {{.SOFA_URL}} 2>/dev/null
        if [ $? -ne 0 ]; then
          echo "‚ö†Ô∏è Warning: Could not connect to Sofa despite port-forwarding being active."
          echo "Will proceed anyway, but operations might fail."
        else
          echo "‚úÖ Successfully connected to Sofa"
        fi
      else
        echo "Skipping port-forwarding checks as requested with --skip-checks"
      fi

      # Check Keycloak pod status instead of trying port-forwarding
      echo "Checking Keycloak pod status..."
      KC_POD_STATUS=$(kubectl get pods -l app=keycloak -o jsonpath='{.items[0].status.phase}' 2>/dev/null)

      if [ "$KC_POD_STATUS" != "Running" ]; then
        echo "‚ö†Ô∏è Keycloak pod is not in Running state (current: $KC_POD_STATUS)"
        echo "Will skip Keycloak authentication"
        
        # Check pod logs for diagnostics
        KC_POD=$(kubectl get pods -l app=keycloak -o name | head -1)
        if [ -n "$KC_POD" ]; then
          echo "Keycloak pod logs (last 10 lines):"
          kubectl logs $KC_POD --tail=10 || echo "Unable to get pod logs"
        fi
        
        BYPASS_KEYCLOAK=true
      else
        echo "‚úÖ Keycloak pod is Running"
        BYPASS_KEYCLOAK=false
        
        # Note: intentionally NOT trying to check port-forwarding that was causing errors
        echo "Note: Skipping Keycloak connectivity check to avoid port-forwarding errors"
      fi

      # Try to create database without authentication first
      echo "Attempting to create database without authentication..."
      RESPONSE=$(curl -s -X PUT "{{.SOFA_URL}}/$DB_NAME" -w "\n%{http_code}")
      HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
      BODY=$(echo "$RESPONSE" | sed '$d')

      if [ "$HTTP_CODE" = "201" ]; then
        echo "‚úÖ Database '$DB_NAME' created successfully without authentication"
        echo "$BODY"
        exit 0
      elif [ "$HTTP_CODE" = "412" ]; then
        echo "‚ö†Ô∏è Database '$DB_NAME' already exists"
        echo "$BODY"
        exit 0
      elif [ "$HTTP_CODE" = "401" ] && [ "$BYPASS_KEYCLOAK" = "true" ]; then
        echo "‚ùå Authentication required but Keycloak is not available"
        echo "Please fix Keycloak issues and try again"
        exit 1
      elif [ "$HTTP_CODE" = "401" ]; then
        echo "Authentication required. Attempting to get a token..."
      else
        echo "‚ùå Failed to create database '$DB_NAME'"
        echo "HTTP Code: $HTTP_CODE"
        echo "Response: $BODY"
        exit 1
      fi

      # If we need authentication but Keycloak should be bypassed, exit now
      if [ "$BYPASS_KEYCLOAK" = "true" ]; then
        echo "Cannot proceed with authentication as Keycloak is not available"
        exit 1
      fi


      # Display available clients from configuration
      echo "Available Keycloak clients:"
      echo "1) sofa-client (Main Sofa application client)"
      echo "2) topology (Topology client with HTTP permissions)"

      # Prompt for client selection
      read -p "Select a client (1-2): " client_selection

      # Set client details based on selection
      case $client_selection in
        1)
          CLIENT_ID="sofa-client"
          CLIENT_SECRET="sofa-client-secret"
          echo "Selected sofa-client"
          ;;
        2)
          CLIENT_ID="topology"
          CLIENT_SECRET="topology"
          echo "Selected topology client"
          ;;
        *)
          echo "Invalid selection. Please select a number between 1-2."
          exit 1
          ;;
      esac

      # Request token from Keycloak using multiple approaches
      echo "Requesting authentication token for client '$CLIENT_ID'..."
      ACCESS_TOKEN=""

      # Attempt method 1: Try using direct kubectl exec with verbose output to see error
      KC_POD=$(kubectl get pods -l app=keycloak -o name | head -1 | sed 's/^pod\///')
      if [ -n "$KC_POD" ]; then
        echo "Attempt 1: Using kubectl exec to curl directly within the Keycloak pod..."
        
        # Get debug info about the pod
        echo "Keycloak pod info:"
        kubectl describe pod $KC_POD | grep -E "Name:|Status:|IP:|Node:|Ready:" || true
        
        # Use a separate command with proper error handling
        {
          # Capture the stderr to see the error message
          EXEC_OUTPUT=$(kubectl exec -i $KC_POD -- curl -v -X POST \
            "http://localhost:8080/realms/sofa/protocol/openid-connect/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=client_credentials&client_id=$CLIENT_ID&client_secret=$CLIENT_SECRET" \
            2>&1) || true
            
          KUBECTL_EXIT=$?
          if [ $KUBECTL_EXIT -ne 0 ]; then
            echo "‚ùå kubectl exec failed with exit code $KUBECTL_EXIT"
            echo "Error output: $EXEC_OUTPUT"
          else
            # Try to extract token from the response
            ACCESS_TOKEN=$(echo "$EXEC_OUTPUT" | grep -o '"access_token":"[^"]*"' | cut -d'"' -f4)
            if [ -n "$ACCESS_TOKEN" ]; then
              echo "‚úÖ Successfully obtained token using kubectl exec"
            else
              echo "‚ùå Could not extract token from response"
              echo "Response: $EXEC_OUTPUT"
            fi
          fi
        } || {
          echo "‚ùå Error during kubectl exec operation, but continuing with other methods"
        }
      else
        echo "‚ùå Could not find Keycloak pod"
      fi

      # Attempt method 2: Try using port-forward to a different port
      if [ -z "$ACCESS_TOKEN" ]; then
        echo "Attempt 2: Trying port-forward to a different port (8090)..."
        
        # Check if any Keycloak port-forward is already running and kill it
        pkill -f "port-forward.*keycloak" || true
        sleep 1
        
        # Start port-forwarding on a different port in a way that won't fail the script
        {
          kubectl port-forward svc/{{.ENVIRONMENT}}-keycloak-service 8090:8080 > /dev/null 2>&1 &
          PF_PID=$!
          echo "Started port-forwarding with PID $PF_PID"
          
          # Give it time to establish
          echo "Waiting for port-forwarding to establish..."
          sleep 5
          
          # Check if process is still running
          if ps -p $PF_PID > /dev/null; then
            echo "Port-forwarding process is still running"
            
            # Try to get a token
            TOKEN_RESPONSE=$(curl -s -X POST \
              "http://localhost:8090/realms/sofa/protocol/openid-connect/token" \
              -H "Content-Type: application/x-www-form-urlencoded" \
              -d "grant_type=client_credentials&client_id=$CLIENT_ID&client_secret=$CLIENT_SECRET") || true
              
            # Try to extract token
            ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | grep -o '"access_token":"[^"]*"' | cut -d'"' -f4)
            if [ -n "$ACCESS_TOKEN" ]; then
              echo "‚úÖ Successfully obtained token using port-forward to 8090"
            else
              echo "‚ùå Could not extract token from response"
              echo "Response: $TOKEN_RESPONSE"
            fi
          else
            echo "‚ùå Port-forwarding process died"
          fi
          
          # Cleanup any port-forwarding we started
          pkill -f "port-forward.*8090" || true
        } || {
          echo "‚ùå Error during port-forward operation, but continuing with other methods"
        }
      fi

      # Attempt method 3: Try directly accessing Keycloak pod's IP
      if [ -z "$ACCESS_TOKEN" ]; then
        echo "Attempt 3: Trying direct pod IP address approach..."
        
        # Get pod IP in a way that won't fail the script
        {
          POD_IP=$(kubectl get pod $KC_POD -o jsonpath='{.status.podIP}' 2>/dev/null) || true
          if [ -n "$POD_IP" ]; then
            echo "Keycloak pod IP: $POD_IP"
            
            TOKEN_RESPONSE=$(curl -s --connect-timeout 3 -X POST \
              "http://$POD_IP:8080/realms/sofa/protocol/openid-connect/token" \
              -H "Content-Type: application/x-www-form-urlencoded" \
              -d "grant_type=client_credentials&client_id=$CLIENT_ID&client_secret=$CLIENT_SECRET") || true
              
            # Try to extract token
            ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | grep -o '"access_token":"[^"]*"' | cut -d'"' -f4)
            if [ -n "$ACCESS_TOKEN" ]; then
              echo "‚úÖ Successfully obtained token using direct pod IP"
            else
              echo "‚ùå Could not extract token from response"
              echo "Response: $TOKEN_RESPONSE"
            fi
          else
            echo "‚ùå Could not get Keycloak pod IP"
          fi
        } || {
          echo "‚ùå Error during direct IP access, but continuing"
        }
      fi

      # Attempt method 4: Try port-forwarding to the Keycloak service using the right port
      if [ -z "$ACCESS_TOKEN" ]; then
        echo "Attempt 4: Trying standard port-forward to the service..."
        
        # Kill any existing port-forwarding
        pkill -f "port-forward.*keycloak" || true
        sleep 1
        
        {
          if [ -n "$KC_POD" ]; then
            # Using the main port-forwarding (30082) which is what the token is issued with
            kubectl port-forward svc/dev-keycloak-service 30082:8080 > /dev/null 2>&1 &
            PF_POD_PID=$!
            echo "Started port-forwarding with PID $PF_POD_PID"
            
            # Give it time to establish
            echo "Waiting for port-forwarding to establish..."
            sleep 5
            
            # Try to get a token
            TOKEN_RESPONSE=$(curl -s -X POST \
              "http://localhost:30082/realms/sofa/protocol/openid-connect/token" \
              -H "Content-Type: application/x-www-form-urlencoded" \
              -d "grant_type=client_credentials&client_id=$CLIENT_ID&client_secret=$CLIENT_SECRET") || true
              
            # Try to extract token
            ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | grep -o '"access_token":"[^"]*"' | cut -d'"' -f4)
            if [ -n "$ACCESS_TOKEN" ]; then
              echo "‚úÖ Successfully obtained token using service port-forward"
            else
              echo "‚ùå Could not extract token from response"
              echo "Response: $TOKEN_RESPONSE"
            fi
            
            # Keep port-forwarding running for token validation
          else
            echo "‚ùå No Keycloak pod found for service port-forwarding"
          fi
        } || {
          echo "‚ùå Error during service port-forward operation, but continuing"
        }
      fi

      # If all else fails, check if Keycloak is actually serving tokens
      if [ -z "$ACCESS_TOKEN" ]; then
        echo "Final diagnostics: Checking if Keycloak pod is actually serving token requests..."
        
        # Get pod logs to check startup status
        echo "Last 20 lines of Keycloak pod logs:"
        kubectl logs $KC_POD --tail=20 || true
        
        echo "Do you want to:"
        echo "1) Continue without authentication (might fail if auth is required)"
        echo "2) Abort the operation"
        read -p "Enter choice (1-2): " continue_choice
        
        if [ "$continue_choice" != "1" ]; then
          echo "Operation aborted"
          exit 1
        fi
        
        echo "Continuing without authentication token..."
      else
        echo "‚úÖ Authentication token obtained successfully"
      fi

      # Create the database with or without the token based on what we have
      echo "Creating database '$DB_NAME'..."
      if [ -n "$ACCESS_TOKEN" ]; then
        echo "Using authentication token"
        RESPONSE=$(curl -v -X PUT "{{.SOFA_URL}}/$DB_NAME" \
          -H "Authorization: Bearer $ACCESS_TOKEN" \
          -w "\n%{http_code}" 2>&1)
        CURL_EXIT=$?
        echo "curl exit code: $CURL_EXIT"
      else
        echo "Attempting without authentication"
        RESPONSE=$(curl -v -X PUT "{{.SOFA_URL}}/$DB_NAME" -w "\n%{http_code}" 2>&1)
        CURL_EXIT=$?
        echo "curl exit code: $CURL_EXIT"
      fi

      # Show full response with verbose output for debugging
      echo "Full curl response:"
      echo "$RESPONSE"

      # Extract HTTP code from the response
      HTTP_CODE=$(echo "$RESPONSE" | grep -o -E '< HTTP/[0-9.]+ [0-9]+' | tail -1 | awk '{print $3}')
      if [ -z "$HTTP_CODE" ]; then
        # Try alternative method to extract HTTP code
        HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
      fi

      # Extract response body
      BODY=$(echo "$RESPONSE" | sed -n -e '/^{/,/^}/p')
      if [ -z "$BODY" ]; then
        BODY="No JSON response body found"
      fi

      if [ "$HTTP_CODE" = "201" ]; then
        echo "‚úÖ Database '$DB_NAME' created successfully"
        echo "$BODY"
      elif [ "$HTTP_CODE" = "412" ]; then
        echo "‚ö†Ô∏è Database '$DB_NAME' already exists"
        echo "$BODY"
      else
        echo "‚ùå Failed to create database '$DB_NAME'"
        echo "HTTP Code: $HTTP_CODE"
        echo "Response Body: $BODY"
        exit 1
      fi

      # Clean up any port-forwarding processes we started (but don't fail if it fails)
      pkill -f "port-forward.*30082" || true
      echo "Note: Any port-forwarding started by this task has been cleaned up."

  insert-document:
    desc: Insert a document into a CouchDB database (requires port-forwarding)
    cmds:
    - |
      # Parse arguments
      args=({{.CLI_ARGS}})
      if [ ${#args[@]} -lt 2 ]; then
        echo "Usage: task insert-document -- <database_name> '<json_document>'"
        echo "Example: task insert-document -- my_database '{\"name\":\"John\",\"age\":30}'"
        exit 1
      fi

      DB_NAME=${args[0]}
      JSON_DATA=${args[@]:1}

      # Check if database exists
      echo "Checking if database '$DB_NAME' exists..."
      DB_CHECK=$(curl -s -o /dev/null -w "%{http_code}" "{{.SOFA_URL}}/$DB_NAME")

      if [ "$DB_CHECK" != "200" ]; then
        echo "Database '$DB_NAME' doesn't exist. Creating it..."
        CREATE_RESPONSE=$(curl -s -X PUT "{{.SOFA_URL}}/$DB_NAME" -w "\n%{http_code}")
        CREATE_HTTP_CODE=$(echo "$CREATE_RESPONSE" | tail -n1)
        
        if [ "$CREATE_HTTP_CODE" != "201" ] && [ "$CREATE_HTTP_CODE" != "412" ]; then
          echo "‚ùå Failed to create database '$DB_NAME'"
          echo "HTTP Code: $CREATE_HTTP_CODE"
          echo "Response: $(echo "$CREATE_RESPONSE" | sed '$d')"
          exit 1
        fi
      fi

      # Insert the document
      echo "Inserting document into '$DB_NAME'..."
      RESPONSE=$(curl -s -X POST "{{.SOFA_URL}}/$DB_NAME" \
        -H "Content-Type: application/json" \
        -d "$JSON_DATA" \
        -w "\n%{http_code}")

      HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
      BODY=$(echo "$RESPONSE" | sed '$d')

      if [ "$HTTP_CODE" = "201" ]; then
        # Extract document ID from response
        DOC_ID=$(echo "$BODY" | grep -o '"id":"[^"]*"' | cut -d'"' -f4)
        echo "‚úÖ Document inserted successfully"
        echo "Document ID: $DOC_ID"
        echo "Full response: $BODY"
        echo "$DOC_ID"  # Output just the ID for easy capture
      else
        echo "‚ùå Failed to insert document"
        echo "HTTP Code: $HTTP_CODE"
        echo "Response: $BODY"
        exit 1
      fi

  retrieve-document:
    desc: Retrieve a document from CouchDB (requires port-forwarding)
    cmds:
    - |
      # Parse arguments
      args=({{.CLI_ARGS}})
      if [ ${#args[@]} -lt 2 ]; then
        echo "Usage: task retrieve-document -- <database_name> <document_id>"
        echo "Example: task retrieve-document -- my_database 1234567890abcdef"
        exit 1
      fi

      DB_NAME=${args[0]}
      DOC_ID=${args[1]}

      # Retrieve the document
      echo "Retrieving document '$DOC_ID' from database '$DB_NAME'..."
      RESPONSE=$(curl -s -X GET "{{.SOFA_URL}}/$DB_NAME/$DOC_ID" \
        -w "\n%{http_code}")

      HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
      BODY=$(echo "$RESPONSE" | sed '$d')

      if [ "$HTTP_CODE" = "200" ]; then
        echo "‚úÖ Document retrieved successfully"
        echo "$BODY" | json_pp  # Pretty print the JSON response
      elif [ "$HTTP_CODE" = "404" ]; then
        echo "‚ùå Document not found"
        echo "Response: $BODY"
        exit 1
      else
        echo "‚ùå Failed to retrieve document"
        echo "HTTP Code: $HTTP_CODE"
        echo "Response: $BODY"
        exit 1
      fi

  round-trip:
    desc: Perform a round-trip operation (create DB, insert document, retrieve document)
    cmds:
    - |
      # Parse arguments
      args=({{.CLI_ARGS}})
      if [ ${#args[@]} -lt 2 ]; then
        echo "Usage: task round-trip -- <database_name> '<json_document>'"
        echo "Example: task round-trip -- my_database '{\"name\":\"John\",\"age\":30}'"
        exit 1
      fi

      DB_NAME=${args[0]}
      JSON_DATA=${args[@]:1}

      echo "üîÑ Starting round-trip test..."
      echo "========================================"

      # Step 1: Ensure the database exists
      echo "Step 1: Creating/checking database '$DB_NAME'..."
      DB_RESPONSE=$(curl -s -X PUT "{{.SOFA_URL}}/$DB_NAME" -w "\n%{http_code}")
      DB_HTTP_CODE=$(echo "$DB_RESPONSE" | tail -n1)
      DB_BODY=$(echo "$DB_RESPONSE" | sed '$d')

      if [ "$DB_HTTP_CODE" = "201" ]; then
        echo "‚úÖ Database '$DB_NAME' created"
      elif [ "$DB_HTTP_CODE" = "412" ]; then
        echo "‚úÖ Database '$DB_NAME' already exists"
      else
        echo "‚ùå Failed to create database"
        echo "HTTP Code: $DB_HTTP_CODE"
        echo "Response: $DB_BODY"
        exit 1
      fi

      echo "========================================"

      # Step 2: Insert the document
      echo "Step 2: Inserting document into '$DB_NAME'..."
      INSERT_RESPONSE=$(curl -s -X POST "{{.SOFA_URL}}/$DB_NAME" \
        -H "Content-Type: application/json" \
        -d "$JSON_DATA" \
        -w "\n%{http_code}")

      INSERT_HTTP_CODE=$(echo "$INSERT_RESPONSE" | tail -n1)
      INSERT_BODY=$(echo "$INSERT_RESPONSE" | sed '$d')

      if [ "$INSERT_HTTP_CODE" != "201" ]; then
        echo "‚ùå Failed to insert document"
        echo "HTTP Code: $INSERT_HTTP_CODE"
        echo "Response: $INSERT_BODY"
        exit 1
      fi

      # Extract document ID from response
      DOC_ID=$(echo "$INSERT_BODY" | grep -o '"id":"[^"]*"' | cut -d'"' -f4)
      echo "‚úÖ Document inserted with ID: $DOC_ID"
      echo "Original document: $JSON_DATA"

      echo "========================================"

      # Step 3: Retrieve the document
      echo "Step 3: Retrieving document '$DOC_ID'..."
      GET_RESPONSE=$(curl -s -X GET "{{.SOFA_URL}}/$DB_NAME/$DOC_ID" \
        -w "\n%{http_code}")

      GET_HTTP_CODE=$(echo "$GET_RESPONSE" | tail -n1)
      GET_BODY=$(echo "$GET_RESPONSE" | sed '$d')

      if [ "$GET_HTTP_CODE" != "200" ]; then
        echo "‚ùå Failed to retrieve document"
        echo "HTTP Code: $GET_HTTP_CODE"
        echo "Response: $GET_BODY"
        exit 1
      fi

      echo "‚úÖ Document retrieved successfully"
      echo "Retrieved document:"
      echo "$GET_BODY" | json_pp  # Pretty print the JSON

      echo "========================================"
      echo "‚úÖ Round-trip test completed successfully!"

      # Return the document ID
      echo "Document ID: $DOC_ID"

  # Sample document creation task
  create-sample-document:
    desc: Create a sample JSON document that can be used with other tasks
    cmds:
    - |
      cat > sample-document.json << EOF
      {
        "name": "John Doe",
        "email": "john.doe@example.com",
        "age": 30,
        "active": true,
        "roles": ["admin", "user"],
        "address": {
          "street": "123 Main St",
          "city": "Anytown",
          "state": "CA",
          "zip": "12345"
        },
        "created_at": "2023-08-15T10:00:00Z"
      }
      EOF
      echo "‚úÖ Sample document created: sample-document.json"
      echo "Usage examples:"
      echo "  - task insert-document -- my_database \"`cat sample-document.json`\""
      echo "  - task round-trip -- my_database \"`cat sample-document.json`\""

  fix-keycloak-jwks:
    desc: Fix Keycloak JWKS configuration and restart the Keycloak pod
    cmds:
    - |
      echo "Fixing Keycloak JWKS configuration..."

      # Apply the updated Keycloak deployment with JWKS configuration
      kubectl apply -f k8s/base/keycloak/deployment.yaml

      # Restart the Keycloak pod to apply the changes
      echo "Restarting Keycloak pod..."
      kubectl rollout restart deployment/{{.ENVIRONMENT}}-keycloak

      # Wait for the Keycloak pod to be ready
      echo "Waiting for Keycloak to restart (this might take a minute)..."
      kubectl rollout status deployment/{{.ENVIRONMENT}}-keycloak --timeout=120s

      # Check if port-forwarding is active for Keycloak
      if ! ps aux | grep -v grep | grep "kubectl port-forward.*{{.ENVIRONMENT}}-keycloak-service.*{{.KEYCLOAK_PORT}}:8080" > /dev/null; then
        echo "Starting Keycloak port-forwarding..."
        kubectl port-forward svc/{{.ENVIRONMENT}}-keycloak-service {{.KEYCLOAK_PORT}}:8080 > /dev/null 2>&1 &
        echo "‚úÖ Started Keycloak port-forwarding"
        
        # Give it a moment to establish
        sleep 5
      else
        echo "Keycloak port-forwarding is already active"
      fi

      # Check connectivity to Keycloak
      echo "Checking Keycloak connectivity..."
      for i in {1..12}; do
        echo -n "."
        sleep 5
        curl -s --connect-timeout 3 -o /dev/null http://localhost:{{.KEYCLOAK_PORT}} 2>/dev/null
        if [ $? -eq 0 ]; then
          echo " connected!"
          echo "‚úÖ Keycloak is now available at http://localhost:{{.KEYCLOAK_PORT}}"
          echo "‚úÖ Admin console available at http://localhost:{{.KEYCLOAK_PORT}}/admin"
          echo "   Username: admin"
          echo "   Password: admin"
          break
        fi
        
        # If we've reached the last attempt, show more detailed diagnostics
        if [ $i -eq 12 ]; then
          echo ""
          echo "‚ö†Ô∏è Could not connect to Keycloak after multiple attempts."
          echo "Checking Keycloak pod status:"
          kubectl get pods | grep keycloak
          echo ""
          echo "Keycloak logs (last 20 lines):"
          kubectl logs $(kubectl get pods -l app=keycloak -o name | head -1) | tail -20
        fi
      done

      echo ""
      echo "To use the fixed Keycloak with database creation, run:"
      echo "task create-database -- <database_name>"

  fix-keycloak-realm:
    desc: Fix the Keycloak realm configuration and restart Keycloak
    cmds:
    - |
      echo "Applying fixed Keycloak configuration..."

      # Apply the updated Keycloak configuration with proper realm name
      kubectl apply -k k8s/overlays/{{.ENVIRONMENT}}

      # Restart the Keycloak pod to apply the changes
      echo "Restarting Keycloak pod..."
      kubectl rollout restart deployment/{{.ENVIRONMENT}}-keycloak

      # Wait for the Keycloak pod to be ready
      echo "Waiting for Keycloak to restart (this might take a minute)..."
      kubectl rollout status deployment/{{.ENVIRONMENT}}-keycloak --timeout=120s || true

      echo "Waiting for Keycloak to fully initialize (30 seconds)..."
      sleep 30

      echo "‚úÖ Keycloak configuration has been fixed."
      echo "Now you can run 'task setup' again to complete the setup process."

  fix-sofa-jwks:
    desc: Fix the JWKS configuration in Sofa to correctly validate tokens from Keycloak
    cmds:
    - |
      echo "Applying fixed Sofa configuration with correct JWKS URL..."

      # Apply only the Sofa ConfigMap
      kubectl apply -f k8s/overlays/{{.ENVIRONMENT}}/sofa-config-patch.yaml

      # Restart the Sofa pod to apply the changes
      echo "Restarting Sofa pod..."
      kubectl rollout restart deployment/{{.ENVIRONMENT}}-sofa

      # Wait for the Sofa pod to be ready
      echo "Waiting for Sofa to restart..."
      kubectl rollout status deployment/{{.ENVIRONMENT}}-sofa --timeout=60s

      echo "‚úÖ Sofa JWKS configuration has been fixed."
      echo "To create a database, run:"
      echo "task create-database -- <database_name>"
      echo ""
      echo "If you encounter connection issues with Keycloak, you can try:"
      echo "1. Run 'task port-forward' in a separate terminal first"
      echo "2. Try 'task create-database -- <database_name> --skip-checks'"

  default:
    desc: Display help information
    cmds:
    - task --list
